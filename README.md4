This is the right mindset.

You donâ€™t want â€œcommands memoryâ€.
You want concept + flow + implementation steps.

Below is your complete reference guide.
You can reuse this anytime in future to rebuild everything from scratch.


---

ðŸ“˜ COMPLETE DEVOPS SETUP REFERENCE GUIDE

(Ubuntu + Docker + Kubernetes + Custom App Deployment)


---

1ï¸âƒ£ Linux Dual Boot Setup (Windows + Ubuntu)

ðŸ”¹ What is Dual Boot?

Dual boot means:

Two operating systems installed on same machine

You choose OS at startup (GRUB menu)


Used because:

Windows â†’ personal usage

Ubuntu â†’ development & DevOps tools



---

ðŸ”¹ High-Level Process

1. Shrink Windows partition (create free space)


2. Create bootable Ubuntu USB


3. Install Ubuntu in free space


4. Install GRUB bootloader


5. Configure UEFI boot entry




---

ðŸ”¹ Step-by-Step Implementation

1. Shrink Windows Partition

In Windows:

Open Disk Management

Right-click main partition

Click â€œShrink Volumeâ€

Create ~50GB free space


Do NOT format it.


---

2. Create Bootable USB

Use Rufus:

Partition scheme: GPT

Target system: UEFI

File system: FAT32



---

3. Install Ubuntu

Boot from USB â†’ Install Ubuntu

Choose:

â€œSomething elseâ€

Select free space

Create:

Ext4

Mount point: /

Size: 50GB


Bootloader device:

/dev/nvme0n1 (entire disk)



Finish installation.


---

4. Fix Boot (if Windows loads directly)

Boot â†’ F9 â†’ Boot From EFI File â†’
EFI â†’ ubuntu â†’ shimx64.efi

Inside Ubuntu:

sudo grub-install
sudo update-grub

Now dual boot works.


---

2ï¸âƒ£ Docker â€“ Containerization

ðŸ”¹ What is Docker?

Docker packages:

Application

Dependencies

Runtime


Into a portable unit called Image.

Running image â†’ Container.


---

ðŸ”¹ Why Use Docker?

Solves:

> â€œIt works on my machine but not on server.â€




---

ðŸ”¹ Install Docker

curl -fsSL https://get.docker.com | sudo bash
sudo usermod -aG docker $USER
newgrp docker

Verify:

docker --version


---

ðŸ”¹ How Containerization Works

Traditional: App â†’ OS â†’ Hardware

Docker: App â†’ Container â†’ Docker Engine â†’ OS â†’ Hardware

Each container:

Is isolated

Shares host kernel

Lightweight (faster than VM)



---

3ï¸âƒ£ Kubernetes & Minikube

ðŸ”¹ What is Kubernetes?

Kubernetes:

Container orchestration system

Manages containers at scale

Handles:

Scaling

Self-healing

Networking

Load balancing




---

ðŸ”¹ What is Minikube?

Minikube:

Runs a single-node Kubernetes cluster locally

Used for development/testing



---

ðŸ”¹ Install kubectl

sudo snap install kubectl --classic


---

ðŸ”¹ Install Minikube

curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

Start cluster:

minikube start

Verify:

kubectl get nodes

If STATUS = Ready â†’ cluster works.


---

4ï¸âƒ£ Building a Node.js Application

ðŸ”¹ Create Project

mkdir devops-app
cd devops-app


---

ðŸ”¹ app.js

const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello from DevOps Kubernetes ðŸš€\n');
});

server.listen(3000);


---

ðŸ”¹ package.json

{
  "name": "devops-app",
  "version": "1.0.0",
  "main": "app.js"
}


---

5ï¸âƒ£ Dockerizing the App

ðŸ”¹ Dockerfile

FROM node:18-alpine
WORKDIR /app
COPY . .
EXPOSE 3000
CMD ["node", "app.js"]


---

ðŸ”¹ Build Image

docker build -t devops-app:v1 .


---

ðŸ”¹ Run Container

docker run -p 3000:3000 devops-app:v1

Access:

http://localhost:3000

App runs inside container.


---

6ï¸âƒ£ Deploying to Kubernetes

ðŸ”¹ Step 1 â€“ Use Minikube Docker

eval $(minikube docker-env)
docker build -t devops-app:v1 .

Now image exists inside Kubernetes environment.


---

ðŸ”¹ Step 2 â€“ Create Deployment

kubectl create deployment devops-app --image=devops-app:v1

What Deployment does:

Creates Pod

Manages replicas

Restarts if crashes



---

ðŸ”¹ Step 3 â€“ Expose Service

kubectl expose deployment devops-app --type=NodePort --port=3000

What Service does:

Gives network access

Maps internal pod port to external port



---

ðŸ”¹ Step 4 â€“ Access Application

minikube service devops-app

Browser opens app.

Now app runs inside Kubernetes.


---

7ï¸âƒ£ Demonstrating Scaling

ðŸ”¹ Scale to 3 Replicas

kubectl scale deployment devops-app --replicas=3
kubectl get pods

Kubernetes now runs 3 copies.

If one crashes: Kubernetes auto-recreates it.

That is orchestration.


---

8ï¸âƒ£ Architecture Summary

You built this:

Developer
â†“
Dockerfile
â†“
Docker Image
â†“
Kubernetes Deployment
â†“
Pods
â†“
Service
â†“
User Access


---

9ï¸âƒ£ How To Explain In Interview

If asked:

What is Docker?

> Docker is a containerization platform that packages application and dependencies into portable images.



What is Kubernetes?

> Kubernetes is a container orchestration system that manages container deployment, scaling, and networking.



What is Minikube?

> Minikube runs a local single-node Kubernetes cluster for development.



How does scaling work?

> Kubernetes maintains desired state defined in Deployment. When replicas are increased, it automatically creates additional Pods.




---

ðŸ”Ÿ What You Have Achieved

You:

Installed Linux dual boot

Installed Docker

Installed Kubernetes

Built an application

Containerized it

Deployed it to cluster

Exposed it via service

Demonstrated scaling


That is full DevOps beginner workflow.


---

If you want next level reference, I can prepare:

CI/CD pipeline explanation

Jenkins integration guide

Terraform + Kubernetes infra explanation

Architecture diagram explanation

20 interview Q&A based on what you built


Tell me which direction you want.